---
layout: post
title: '2023-01-task'
category: task
tag: post
---

# 2023-01-03
1. 호를 그리는 궤적 생성하기(o)
2. atan과 atan2의 차이 
3. float for문의 어려움

# 2023-01-04
1. 블로그 정리(o)
2. atan과 atan2의 차이(o)
3. 쿼터니온
4. float for문의 어려움
5. 검을 장착하고 호의 수직길이와 검의 수평 길이만큼 공격범위가 시각화되고 해당 범위로 공격 처리가 되도록 설계(o)

# 2023-01-05
1. 검을 장착하고 팔을 움직일 수 있도록 설계(팔 움직이는 것만 설계)
2. 실제 적 구현(Enemy stats 일부 구현)
3. 검 공격 효과 애니메이션 처리와 데미지 처리(데미지 처리 일부 구현)
4. 쿼터니온
5. float for문의 어려움

# 2023-01-06
1. 검 장착(x)
2. 실제 적 구현 마무리(x)
3. 검 공격 효과 애니메이션 처리 및 데미지 처리 마무리(x)
4. 쿼터니온 정리(x)
5. float for문의 어려움(x)

# 2023-01-07
1. 검 장착(o)
2. 실제 적 구현 마무리(x)
3. 검 공격 효과 애니메이션 처리 및 데미지 처리 마무리(x)
4. 쿼터니온 정리(x)
5. float for문의 어려움(x)

+ Translate 와 Vector3 pos에 직접 더하는 것과의 차이

Translate는 현재 Transform의 상대 좌표계를 기준으로 이동시키고 transform.postion += postion은 World 좌표계를 기준으로 이동시킬 수 있다.


# 2023-01-08
1. 실제 적 구현 마무리(o)
2. 검 공격 효과 애니메이션 처리 및 데미지 처리 마무리(o)
- DrawArc2D 수정: Arc의 Start color와 end Color에 따라서 alpha를 조정해야함
- FadeAwayArc2D 수정: 한쪽은 이미 alpha가 0이니까 그부분은 제외하고 fade out 되도록 설계
- SwordAtkTrajController에서 팔의 회전 애니메이션을 추가해야함 - first, second guide object에 따라서
3. RayCastHit2D의 판정? - RaycastAll과 Raycast의 차이에 주의

[No 디버깅]
![](/asset/gifs/Sword_test_1.gif) 


[ 디버깅 ]
![](/asset/gifs/Sword_test_2.gif)  


1. 쿼터니온 정리(x)
2. float for문의 어려움(x)
3. swap 함수


# 2023-01-09
1. 못함(사유: 친구들이랑 놀아서)

# 2023-01-10
![](/asset/gifs/Zombie_debug.gif)  
1. Zombie 이동 - 그라운드에서 떨어지지 않도록 하기, Player를 보는 방향으로 움직이게 하기(x) -> 하긴 했는데 일단 Player를 검출하는 함수와 바닥에 떨어지지 않도록 하는 함수 둘다 LocalScale을 조정하여 좌우 반전을 시키는데, 두 함수 실행이 왔다갔다 반복이 되면 저런 식으로 Scale이 왔다 갔다 한다.   

 따라서 Player에 데미지를 줄땐 넉백이 필요하고 만약 특정 범위 내에서 Player가 존재하면 Scale을 바꾸지 않으며 Animation을 정지시켜야한다. 그리고 Zombie 동작을 간단하게 설계할 수 있는 방법이 필요함


1. Player 이동 부드럽게 만들기(x)
2. UI 시스템 슬슬 만들기(x)


3. 쿼터니온 정리(x)
4. float for문의 어려움(x)
5. swap 함수

Layermask는 체크 되어있는 쪽은 인정해주는 쪽이고 안된쪽은 인정해주지않는 쪽

# 2023-01-11

![](/asset/gifs/Zombie_move.gif)  
## 1. Zombie 이동(o)

Zombie의 이동 패턴을 구현할때
1) 플레이어 탐색
2) 지면 고정 처리
3) 플레이어 인접 확인

이 세가지 패턴으로 구현을 했었는데, 매 프레임마다 처리해야하는 패턴의 우선 순위를 지정하는 것이 쉽지않았다. 

처음에는 '지면 고정 처리'가 가장 우선이 되어야한다고 생각했었지만 위에서 생겼던 부적절한 좌우 반전 반복 현상을 제거하기 위해서는 '플레이어 인접 확인'을 우선시 해야했다.  

각 패턴들은 수평 방향의 Raycast를 사용했으며 이 Raycast의 거리에 조건을 걸어야했다. 예를 들어 지면 고정 처리를 위한 지면 탐색 범위가 너무 크면 좀비의 움직임 범위가 줄어든다. 또한 지면 탐색 범위가 플레이어 인접 범위보다 적으면 "지면 고정 처리"와 "플레이어 탐색" 패턴이 짧은 주기로 반복이 되면서 위에서 관찰한 좌우 반전 반복 현상이 발생한다.

최종적으로 플레이어 탐색 범위(파란색) > 플레이어 인접 범위(빨간색) > 지면 확인 범위(검정색)이어야함을 알 수 있었다.

추가적으로 현재 2D 게임을 제작하고 있기에 3D 게임에서 해당 패턴을 구현한다면 수평 Raycast를 사용하는 것은 불가능하며 
원 형태로 주변의 지면을 탐색하고 플레이어를 탐색하고 플레이어가 인접한지 확인해야할 것이다.

## Raycast
RaycastHit2D의 경우 정의를 살펴보면


RaycastHit2D.cs

''' C

    public static implicit operator bool(RaycastHit2D hit)
        {
            return hit.collider != null;
        }

'''
이러한 연산자가 정의되어있는데, RaycastHit2D 변수 자체로 bool 값을 가지고 있으며 이는 Raycast에 맞은 collider가 존재하면 true이고 없으면 false를 반환한다.

처음에는 RaycastHit2D가 Transform과 비슷하다고 생각해서 두 RaycastHit2D 인스턴스를 비교문에 사용했지만 bool값을 비교하는 것이기 때문에 잘못된 사용법에 해당한다.

두 RaycastHit2D에 해당하는 인스턴스가 같은지 다른지 비교하려면 멤버 함수중에 transform에 접근하여 두 Transform 정보가 같은지 비교해야한다.

## float for문의 어려움(o)
보통 반복문은 int 변수를 사용하여 반복 횟수를 정수값으로 늘려가며 반복한다. 

'''
   
    for(int i = 0; i < maxRange; i++)

'''

그런데 만약 변수가 float일 경우에는 사용하기 복잡하고 범위값이 매번 달라질 경우에 몇번까지 반복될지 알 수 없다. 

''' C

    for(float i = 0; i < maxRange; i += n)

'''

마찬가지로 반복문내에서 배열 요소들을 계산하고 배열에 저장할때 배열의 크기를 예측하기 쉽지않으므로 반복문을 사용할때는 정확도가 요구되는 경우가 아니라면 int 변수를 사용하는 것이 맞다.


1. Player 이동 부드럽게 만들기(x)
2. UI 시스템 슬슬 만들기(x)


3. 쿼터니온 정리(x)
4. swap 함수: Swap 함수를 Static 함수로 만들려면 인자에 ref 키워드가 필요한데, static 함수를 메모리에 적재시키고 ref 키워드로 하는 것보다 그냥 즉석에서 tmp 변수 하나 만들고 교환하는 게 나을 듯

# 2023-01-12

1. Player 이동 부드럽게 만들기()
2. UI 시스템 슬슬 만들기()

3. 쿼터니온 정리(x)