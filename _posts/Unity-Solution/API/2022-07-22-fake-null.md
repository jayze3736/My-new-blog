---

layout: post
title: '유니티의 Fake null 문제'
category: Unity-Solution
tag: API

---

# Fake null이란?
Fake null은 유니티에서 제공하는 'Destroy(object)' 함수를 이용하여 객체를 삭제하고 (Object == null)의 비교 연산하면 거짓을 반환하는 문제에 해당한다.    
문제는 '==' 연산자의 오버로딩으로 인해 유니티의 객체에 래핑된 Object instance가 비교되어 null이 아니라고 판단하게되는 부분이다.  
   

## - Wrapper 클래스
래퍼 클래스는 일반적으로 원시형의 데이터(primitive data)를 객체타입으로 사용하기위해서 새롭게 정의한 클래스를 의미한다.    
즉, 기존의 데이터를 사용자의 목적에 맞게 사용할 수 있도록 새로운 클래스를 정의한 것을 래퍼 클래스라고 한다.    
일반적으로 원래 데이터값을 참조하여 새로운 Wrapper 클래스의 인스턴스를 생성하고 이를 사용한다.

## - Unity 엔진은 원래 C++
Unity를 사용할때 스크립트 언어는 C#을 사용한다. 그래서 유니티의 모든 기능이 C#을 이용한 것인줄 알았다.   
 하지만, 실제로 유니티 엔진은 C++로 만들어졌고 C#의 기능을 확장시켜서 개발하도록 만들어져있다.    
 기본적으로 코드를 작성할때 C#을 이용하고 유니티 에디터의 UI도 C#을 이용하여 만들어져 있다고 한다.

## - 왜 C#을 사용하는가?
이에 대한 질문은 C++과 C#의 기능을 비교해보면된다. C++과 C#의 가장 큰 차이는 메모리 할당에 있다.   
 C++의 경우 메모리 할당 및 해제 코드를 사용자가 직접 작성하여 수동으로 메모리 관리를 하게하지만 C#의 경우 자동으로 메모리 관리를 해준다.   

C++의 경우에는 메모리 관리가 수동으로 이루어지므로 메모리 관리 효율을 높일 수 있다는 장점이 있지만 이에 대한 코드를 더 작성해야 하므로 메모리 관리에 수고를 덜어야한다는 단점이 있다.   
C#의 경우에는 이와 반대로 메모리 관리가 자동으로 이루어지므로 메모리 관리에 대한 수고를 덜 수 있다는 장점이있다.   
따라서 유니티는 배우기 쉽게 만들기위해 이렇나 C#의 기능을 채택한 것으로 보인다.

## - Object 클래스
Unity 엔진은 C++로 만들어져있다. 그러나 우리가 C#의 기능을 사용하기위해서는 기존의 C++ 데이터를 C# 환경(.NET)에서 사용하기위해서 만들어진 래퍼 클래스가 바로 Object 클래스이다.   
Object 클래스는 유니티에서 사용하는 모든 클래스의 베이스 클래스이다.

## - Destroy 함수
Object로 래핑되어있는 객체는 두가지 객체를 가진다. 하나는 원래 데이터에 해당하는 C++ 객체, 그리고 다른 하나는 래핑되면서 만들어진 C#(Object 클래스) 객체이다.   
Destroy 함수는 실제로 삭제할때 객체를 메모리에서 완전히 제거하는 것이아니라, Destory함수는 C++의 객체만을 제거한다.    
C#의 객체는 GC(Garbage Collector)가 수거해갈때까지 기다려야 완전히
객체에 대한 정보가 메모리에 남지않게 된다.  
참고로 Destroy 함수를 실행하면 C++ 사이드의 객체(native object)가 사라지므로 C# 사이드의 객체가 살아있어도 객체의 함수나 기능을 사용하지 못한다고 한다.   
즉, native object는 실제 객체의 알맹이이고 C#으로 래핑된 부분은 C# 기능을 사용하기 위한 껍데기라고 볼 수 있다.

## - == 연산자
Destory 함수로 객체를 제거하여 C++ 객체를 제거했지만 C#의 객체를 GC가 아직 수거해가지않은 상황에서 '== null' 과같은 널체크가 이루어지면 어떻게 될까?  
먼저 == 연산자는 Object 객체에 대하여 Object 클래스에 정의된 == 연산자를 오버로드하여 호출한다.
이렇게 되면 C#의 객체가 아직 살아있기때문에 null체크시 거짓을 반환하여 null이 아니라고 인식하게 되며 원치않는 프로그래밍 흐름이 발생한다.


# - Solution
1. Destory 함수는 C++의 객체를 삭제하므로 만약 null 체크가 필요하다면 C++의 객체(native object)를 대상으로 null 체크를 해주면 된다.
2. 이에 대한 비교 메소드는   
+ Assert.IsnotNull(object obj, string message),    
+ object.ReferenceEquals(value, null)   
+ 또는 객체를 object(UnityEngine.Object가 아닌 System.Object)로 형변환하여 null 체크를 해준다.(== null)

# - 참고
- 래퍼 클래스란?: http://www.tcpschool.com/java/java_api_wrapper
- Fake Null  
https://overworks.github.io/unity/2019/07/22/null-of-unity-object-part-2.html  
https://overworks.github.io/unity/2019/07/16/null-of-unity-object.html#fn:1  
https://ansohxxn.github.io/unitydocs/fakenull/ 
- Unity엔진은 C++?  
https://gamedevforever.com/203
- unity의 GC 방식과 Destroy  
https://answers.unity.com/questions/745685/nullreferenceexception-on-startcoroutine.html








