---
title: 'Numpy API 정리'
category: Class_Memo
tag: 기계학습
layout: post
---
# Index
- [Index](#index)
- [API List](#api-list)
- [Addtive Description](#addtive-description)
- [ndarray.shape()](#ndarrayshape)
- [ndarray.astype(type)](#ndarrayastypetype)
- [int 32 vs int 64](#int-32-vs-int-64)
- [reshape(z,y,x)](#reshapezyx)
- [[ : ] 슬라이싱](#---슬라이싱)
- [다차원 슬라이싱](#다차원-슬라이싱)
  - [슬라이싱 트릭](#슬라이싱-트릭)
- [argsort()](#argsort)


(이거 테이블 쓸때 API List 줄바꿈이 한칸 비어있어야함 줄바꿈없이 쓰면 인식 불가능)
# API List

|번호|함수|용도|note|
|:---:|:---:|:---:|:---:|
|1|np.array(list)|list를 ndarray로 변환 |None|
|2|type(data)|data의 타입을 반환|None|
|3|ndarray.shape|ndarray의 행렬 크기를 반환|ex) 반환값 = (행개수, 열개수)|
|4|np.arange(n)|0~(n-1)까지의 벡터 행렬을 반환|np.arange(a, b)는 a부터 b-1까지의 벡터 행렬을 반환|
|5|ndarray.ndim|ndarray의 차원 반환|벡터일 경우 1, 행렬일 경우 2, 3차원 행렬일 경우 3|
|6|ndarray.dtype|ndarray의 요소 타입을 반환|None|
|7|np.zeros(shape, dtype)|인자로 입력한 shape와 요소 타입 dtype을 가진 0으로 초기화된 행렬 반환 |shape는 (a,b) 식으로 행과 열을 줄 수 있고 dtype은 반드시 'int64' 처럼 ' 으로 닫아야한다.|
|8|np.ones(shape, dtype)|zeros와 동일하되 0이 아닌 1로 초기화 한다.|None|
|9|ndarray.reshape(a, b)|ndarray의 모양을 변경|3행 2열의 행렬(3, 2)를 2행 3열 행렬(2, 3)로 변경가능 변경 불가능시 예외 발생, 3차원으로 변경시 ndarary.reshape(z, y, x) 순으로 결정되며 z는 높이, y는 행의 개수, x는 열의 개수를 의미한다.|
|10|ndarray.tolist()|ndarray를 list로 변환|None|
|11|ndarray.copy()|ndarray와 값은 같되, 참조가 다른 ndarray 반환|None|
|12|ndarray[ a:b:c ]|슬라이싱, ndarray의 인덱스 범위를 주고 해당 인덱스 위치에 있는 요소를 반환|a는 start, b-1는 end, c는 step에 해당함. step은 start부터 end까지 step값의 배수만큼 인덱스를 뽑는다고 생각하면 됨, 예를 들어 0:7:2 면 0부터 6까지 2의 배수만큼 인덱스를 뽑으므로 0, 2, 4, 6에 해당하는 인덱스를 반환한다.|
|13|ndarray[ a:b:c, a:b:c]|다차원 슬라이싱, ndarray가 고차원 행렬일 경우 특정 인덱스에 위치한 요소로 구성된 행렬을 반환할 수 있다.|링크: |
|14|ndarray[ :a ], ndarray[ a: ], ndarray[ : ]| 슬라이싱을 할때 처음, 끝을 지정할 수 있다. :a는 처음부터 a-1까지, a:는 a부터 끝까지, :는 전체를 의미한다.|None|
|15|ndarray[[ a:b ], c]|팬시 인덱싱, 인덱스 집합을 주어 특정 인덱스의 요소를 추출하여 처리하는 것이 가능|None|
|16|ndarray[ (condition) ]|불린 인덱싱, ndarray를 대상으로 하는 조건문은 결과로 bool 타입의 리스트를 주는데 이 리스트가 ndarray의 bracket([])인자로 입력하면 리스트의 true인 위치의 요소만으로 구성된 행렬을 반환한다.|None|
|17|np.sort(ndarray)|ndarray를 정렬한 훟 값을 반환한다.|None|
|18|ndarray.sort()|ndarray를 정렬한 후 값을 반환하지 않는다.|None|
|19|ndarray[ ::-1 ]|ndarray의 전체 요소를 거꾸로 반환|[ 0,1,2 ]이면 [ 2,1,0 ] 반환|
|20|np.argsort(ndarray)|실제 array를 정렬했을때 원본 array가 어디에 위치하게될지 인덱스 리스트를 반환한다. 오름 차순으로 정렬하므로 주의, 보통 정렬할 수 없는 리스트를 처리할때 사용한다.|링크: |
|21|np.dot(ndarrA, ndarrB)|행렬의 내적곱|None|
|22|ndarray.astype(type)|행렬 요소의 타입을 type으로 변경|None|
|23| | |None|
|24| | |None|
|25| | |None|
|26| | |None|
|27| | |None|
|28| | |None|
|29| | |None|


# Addtive Description

# ndarray.shape()
행렬이 n x n이면 (n,n) 반환, n이면 (n,) 반환, n x n x n이면 (n, n, n) 반환

# ndarray.astype(type)
type에는 'int64', 'int32', 'float64', 'float32' , '<U11' ... 이 존재 '<U11' 은 유니코드를 의미한다.

# int 32 vs int 64
표현할 수 있는 정수 범위가 다르며 int32와 int64는 할당하는 메모리가 각각 32비트 64비트이다.
기본적인 int 타입을 사용할때는 운영체제에 따라 int32 또는 int64를 사용할지 결정되며 32비트 운영체제의 경우 int32, 64비트 운영체제의 경우 int64를 사용한다고 한다.  

# reshape(z,y,x)
3차원으로 reshape할때 reshape((z,y,x))  처럼 된다. 여기서 z는 높이, y는 행 개수, x는 열 개수가 된다. 3차원이기때문에 2차원의 행렬이 탑처럼 층층이쌓이는 모습이된다. 1차원은 선, 2차원은 면, 3차원은 입체 큐브 정도로 생각하면 된다.

# [ : ] 슬라이싱
[:] 슬라이싱을 이용하여 원본과 크기가 다른 배열을 받아도 요소의값을 바꾸면 원본 요소값도 바뀌게 된다. 예를 들어서 A = [1,2,3]인데, B = A[:1]로 슬라이싱하여 B = [1,2]를 반환받았을때, B[0] = 7 처럼 값을 수정하면 A[0] 도 1이 아닌 7이 된다.

# 다차원 슬라이싱
  다차원의 슬라이싱은 행렬의 특정 위치의 요소값을 동시에 반환하기에 적합하다.  
행렬에서 특정위치에 있는 요소를 각 행렬에서 가져오는 것이 가능하다. 예를 들어서 다음과 같은 이차원 행렬이 있다고 하자.   
[[0 1 2 3 4]    
 [5 6 7 8 9]]     
여기서 각 행에서 4,5열 위치에 있는 요소(3,4,8,9)만을 가져오고 싶다고 해보자.  
arr = arr[: , 3:5]이면    
[[3 4]  
 [8 9]]을 반환한다.
다음 예로 3차원을 들어보자.  

[[[ 0  1  2]  
  [ 3  4  5]  
  [ 6  7  8]]  
   
 [[ 9 10 11]  
  [12 13 14]  
  [15 16 17]]  
   
 [[18 19 20]  
  [21 22 23]   
  [24 25 26]]]  

인 3차원 행렬을 [0:2, :, 1:3] 대로     슬라이싱하면     
[[[ 1  2]    
  [ 4  5]    
  [ 7  8]]    
    
 [[10 11]  
  [13 14]  
  [16 17]]]   
이 된다.    

## 슬라이싱 트릭
슬라이싱은 차원과 슬라이싱 인수 개수에 따라 다르게 처리한다.
특정 행렬에서 특정 위치에 있는 값만으로 구성된 행렬을 반환받고 싶을 경우 2차원이면 2개, 3차원이면 3개의 슬라이싱 인수를 전달해야한다.   
만약 더 적게 인수를 제공했을 경우에는 단순히 제공한 슬라이싱 인수 범위의 행렬을 반환하기때문에 가장 안쪽에 있는 요소에 도달할 수 없다.(말이 좀 이상한가?)  
따라서 슬라이싱을 잘 하려면 현재 데이터 차원이 2개면 2개를 전달해야함을 인지해야하고 두번째 인수전까지 내가 어느 범위에서 특정 위치의 요소를 반환할 것인지 생각해야한다.  
  
   
[[[ 0  1  2]   
  [ 3  4  5]   
  [ 6  7  8]], 　
　

[[ 9 10 11]  
[12 13 14]  
[15 16 17]], 

 [[18 19 20]  
  [21 22 23]  
  [24 25 26]]]   
　

[0:2, :, 1:3]  
　

1) 0:2 이므로 0,1 번째인   
[ 0  1  2]    
[ 3  4  5]   
[ 6  7  8]],
　
  
[[ 9 10 11]  
[12 13 14]   
[15 16 17]]을 선택    

2) : 이므로 각 행렬에서 3행까지 모두 선택
3) 2)에서 3행까지 선택했고 1~3행까지 1 부터 2열까지 위치한 요소만을 반환  
[[10 11]  
  [13 14]  
  [16 17]]]  


# argsort()
np.argsort(array)는 실제 array를 정렬했을때 원본 array가 어디에 위치하게될지 인덱스 리스트를 반환한다. 

오름 차순으로 정렬하므로 주의
argsort는 팬시 인덱싱과 함께 사용하기 유용하다.   
팬시 인덱싱은 arr[(인덱스 리스트 or 집합)] 형태로 값을 넣으면 해당 집합에 있는 인덱스를 차례로 값을 위치시켜 행렬로 만든다.   
Execute)   
name_arr = np.array(['A', 'B', 'C', 'D', 'E'])  
score_arr = np.array([7,2,5,7,2])  
sort_indices = np.argsort(score_arr)  
print(sort_indices)   
print(name_arr[sort_indices]) <- 이 부분이 팬시 인덱싱, name_arr에서 1, 4, 2, 0, 3번째 요소를 차례로 위치시켜 행렬 생성

Result)  
[1 4 2 0 3]  
['B' 'E' 'C' 'A' 'D']   

