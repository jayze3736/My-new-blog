---
layout: post
title: '2022-08-26-TIL'
category: TIL
tag: post
---

logic과 view를 분리하지않으면 생기는 단점:

예를 들어서, 아이템을 먹으면 Inventory에 해당 아이템을 slot에 위치시키는 시스템이 있다고 해보자.
logic과 view가 한 스크립트 내에서 정의된다고 해보자. 플레이 도중에 아이템을 먹게 되면 인벤토리 메뉴를 열기전까지는 인벤토리 프리팹과 스크립트는
활성화가 되지않은 상태일 것이다. 만약 활성화가 되어있다고해도 아이템을 먹자마자 인벤토리를 보여주는 방법은 플레이 방식에 있어서 어긋나기때문에
인벤토리 프리팹은 활성화시키고 투명도(alpha)를 0으로 세팅하는 방식으로 해야 아이템을 먹었을때 해당 객체에 메세지가 전달되어 먹은 아이템의 처리가
이루어질 것이다.  그러나 이 방법은 메모리 효율을 저하 시킬 것이 당연하며 로직 데이터의 변경이 view에 적용되어야할때 메모리 점유가 상당할 것이다.
따라서 logic과 view를 분리시켜야하며, 이를 분리시키게되면 중요한 로직 데이터는 플레이 타임 동안에 살리고 view를 없애고 싶을때 없앤다음 필요할때 다시 불
러서 살아있던 로직 데이터를 참조하여 view를 업데이트시키는 방식으로 진행할 수 있다.
실제로 적용이되면, 필드에서 아이템을 먹으면 인벤토리 프리팹이 존재하지않아도 로직 데이터의 업데이트가 일어날 수 있고 나중에 플레이어가 인벤토리 메뉴를
열때 로직 데이터를 읽어서 인벤토리 메뉴를 참조시키는 방식으로 진행하면 인벤토리 프리팹을 항상 씬에서 유지해야할 필요없이 로직을 업데이트할 수 있다.

이렇게되면 전역 객체를 사용해야함이 불가피해진다. 왜냐하면 로직 데이터는 여러 스크립트에서 참조가 가능해야하며 초기화작업이 일반 지역 객체 또는 필드 보다
먼저 처리되어야하므로 전역 객체를 사용해야한다. 따라서 싱글톤 패턴을 사용하여 로직 데이터의 접근을 받는 객체를 하나로 정하고 해당 객체에서 로직 데이터를
요구하면 데이터를 반환하는 방식으로 진행되어야한다. 

그런데 이게 정확히 데이터 바인딩이라고는 볼 수 없을 것같다. 왜냐하면 어떤 데이터의 참조를 프로그램 실행 이전에 결정할 수 있도록하여 
프로그램 실행이되면 해당 참조로 데이터를 가져와서 진짜 참조를 대입하는 방법에 해당하는데, 스크립트 내에서 참조를 결정하게 되면 이거는 평소 잘 알려진
데이터 바인딩이라고 보긴 어려울 것 같다. 그래서 이 경로를 Inspector에서 정할 수 있도록 무언가의 장치가 필요할 것으로 예상된다.

1. Logic<> wrapper 클래스를 언제 사용해야하는가?
PlayerStatus{
int hp
float mp
string nickname
}
다음과 같은 필드의 객체에서 PlayerStatus로 랩을 해야하나 아니면 hp, mp, nickname으로 랩을 해야하나
a. hp, mp, nickname 모두 logic으로 랩하고 GameLogicNode로 저장한다. 그리고 Event를 추가할때 해당 경로의 이벤트 핸들러를 반환하여 추가한다.
b. PlayerStatus만 logic으로 랩하고 Event를 추가할때는 해당 PlayerStatus에 정의된 이벤트 핸들러를 가져와서 추가한다.

2. Logic wrapper 클래스는 제네릭 클래스로, Logic 데이터를 랩하며, 해당 로직 값이 바뀌었을때의 이벤트 처리를 담당하며 

3. 계층 구조를 가지는 view 또는 로직 데이터들의 Event 연쇄 처리를 해야하나? 한다면 어떻게 처리?

4. Logic<int> maxhp = new Logic<int>("TestPlayerStatus.MaxHP, 5);
-> 이런식으로 생성자 시점에 바인딩이 이루어지는거 별로인듯,
a. TestPlayerStatus는 parent path이므로 TestPlayerStatus.을 없앴음 함
b. 값 초기화까지는 괜찮은데, (그래 일단 이거는 넘어가자.)
c. binding 시에 작성해야하는 데이터들과 인자를 최소한으로 하고 싶음
초기화할때 View에서 초기화시키는 건 어떨까? 어쨌든 Logic은 Inspector에서 바꿀 수 없고 오로지 모노가 장착된 클래스 오브젝트만
Inspector에서 바꾸는게 가능하니까 초기화 값이나 테스트값을 정하려면 view쪽에서 디폴트 값을 정해주는게 맞다고 생각함
=> 1. 초기화 값은 로직쪽에서 정하는 것이 아닌 View 쪽에서 하는 것
=> 2. GameLogicNode를 생성하고 저장하는데 필요한 요소는 두가지 1. Value, 2. bindingPath


- 제네릭을 사용한다면 더더욱이 인터페이스의 필요도가 늘어나며, 제네릭 필드를 참조해야하는 경우 object로 선언된 Value 프로퍼티를 인터페이스에 정의하면 인터페이스에서도 해당 Value 값을 가져올 수 있다.




1. Logic<T> 생성자에 Path 던지기
2. Context 클래스 안에 있는 Logic<T> 필드를 검사한다음, 해당 필드로 path 결정
3. 리플렉션 없이 생성만해서 path를 결정하는 것은 불가능




2번:
LogicContext를 상속받는 클래스는 객체 생성과 동시에 리플렉션을 통해 해당 클래스의 필드를 모두 가져와서 ILogic을 상속받고 있는 Logic<T> 타입 필드를 가져온다.
해당 타입 필드 인포의 Name을 가져와서 path로 지정한다. 이때 Context에 관한노드 생성과 같이 이루어지기때문에 parent child 관계가 명확하게 이루어질 수 있다.
=> 난 이게 거의 맞다고 생각함. 왜냐하면 parent를 생성하고 나면 parent에 대한 참조가 있어서 또 다시 parent를 찾지않아도 바로 child를 지정할 수 있어서 task가 줄으니까
만약 각 Logic 필드별로 경로를 줘서 parent를 매 필드마다 반복적으로 찾게되면 찾는 경로가 길면 길수록 비효율적이라고 생각한다.

-> 리플렉션 없이 생성자 호출시 필드 이름(nameof(field)) 그리고 Logic<T> 값을 전달하여 해당 노드 생성, ContextNode 는 child를 가지는 것을 허용하고 LogicNode는 순수 primitive data의 logic이며 child를 가질 수 없게 만들까?


Logic(context




아이템의 레퍼런스를 Scriptable Object로 지정하고 아이템을 먹었을때 이에 대한 처리를 레퍼런스를 대상으로 진행한다.
구체적으로 무슨뜻이냐면, 아이템에 대한 정보를 포함하는 ScriptableObject를 생성할 아이템 오브젝트 필드에 캐싱한다음 이미 인벤토리에 해당 레퍼런스가 있으면 그 아이템의 수량만 늘려주고 추가적인 작업을 하지않는다.




# 배운점
1. 제네릭 클래스일 경우 인터페이스의 중요도가 더욱 증가한다.
2. nameof()를 사용하여 변수 이름을 반환 받을 수 있다.










